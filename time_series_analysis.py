# -*- coding: utf-8 -*-
"""Time Series Analysis.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yUVuXF5QhxyR_Vc3EWKSpOuoA898hr9W
"""

!pip install pandas numpy matplotlib seaborn statsmodels python-binance yfinance

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import itertools
import warnings
from statsmodels.tsa.stattools import adfuller
from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error, mean_absolute_percentage_error
from math import sqrt
from datetime import datetime, timedelta
import yfinance as yf

warnings.filterwarnings('ignore')

# Set style for plots (fallback to 'ggplot' if 'seaborn' not available)
try:
    plt.style.use('seaborn')
except:
    plt.style.use('ggplot')
plt.rcParams['figure.figsize'] = [12, 6]

def load_eth_data(start_date='2020-01-01', end_date='2023-01-01'):
    """Load Ethereum historical data from Yahoo Finance"""
    try:
        print("Loading data from Yahoo Finance...")
        df = yf.download('ETH-USD', start=start_date, end=end_date)
        df.index.name = 'date'

        # Approximate market cap (circulating supply * price)
        circulating_supply = 120_000_000  # Approx ETH supply
        df['market_cap'] = df['Close'] * circulating_supply

        # Rename columns
        df = df.rename(columns={
            'Open': 'open',
            'High': 'high',
            'Low': 'low',
            'Close': 'close',
            'Volume': 'volume'
        })

        return df[['open', 'high', 'low', 'close', 'volume', 'market_cap']]

    except Exception as e:
        print(f"Failed to load data: {e}")
        print("Generating synthetic data for demo...")
        dates = pd.date_range(start=start_date, end=end_date)
        np.random.seed(42)
        base_price = 100 + np.cumsum(np.random.normal(0, 5, len(dates)))

        return pd.DataFrame({
            'date': dates,
            'open': base_price,
            'high': base_price + np.random.uniform(0, 10, len(dates)),
            'low': base_price - np.random.uniform(0, 10, len(dates)),
            'close': base_price,
            'volume': np.random.randint(100_000, 500_000, len(dates)),
            'market_cap': base_price * circulating_supply
        }).set_index('date')

# Load data
eth_data = load_eth_data()
print("\nFirst 5 rows:")
print(eth_data.head())

# Display last 5 rows
print("\nLast 5 rows:")
print(eth_data.tail())

# Basic statistics
print("\nDescriptive Statistics:")
print(eth_data.describe())

def perform_eda(df):
    """Perform exploratory data analysis"""
    print("\n=== Exploratory Data Analysis ===")

    # Price trend
    plt.figure(figsize=(14, 7))
    df['close'].plot(title='ETH/USDT Price History', color='steelblue')
    plt.ylabel('Price (USDT)')
    plt.grid(True)
    plt.show()

    # Moving averages
    plt.figure(figsize=(14, 7))
    df['close'].plot(label='Daily Price', alpha=0.5)
    df['close'].rolling(30).mean().plot(label='30-day MA', color='red')
    df['close'].rolling(90).mean().plot(label='90-day MA', color='green')
    plt.title('Price with Moving Averages')
    plt.legend()
    plt.grid(True)
    plt.show()

    # Volume analysis
    plt.figure(figsize=(14, 7))
    df['volume'].plot(title='Trading Volume', color='purple')
    plt.ylabel('Volume')
    plt.grid(True)
    plt.show()

    # Daily returns (volatility)
    returns = df['close'].pct_change()
    plt.figure(figsize=(14, 7))
    returns.plot(title='Daily Returns', color='orange')
    plt.ylabel('Return (%)')
    plt.grid(True)
    plt.show()

perform_eda(eth_data)

def test_stationarity(series):
    """Check stationarity using Augmented Dickey-Fuller test"""
    print("\n=== Stationarity Test ===")

    result = adfuller(series.dropna())
    print('ADF Statistic:', result[0])
    print('p-value:', result[1])
    print('Critical Values:', result[4])

    # Plot rolling stats
    rolling_mean = series.rolling(30).mean()
    rolling_std = series.rolling(30).std()

    plt.figure(figsize=(14, 7))
    plt.plot(series, label='Original')
    plt.plot(rolling_mean, label='Rolling Mean', color='red')
    plt.plot(rolling_std, label='Rolling Std', color='black')
    plt.legend()
    plt.title('Rolling Statistics')
    plt.grid(True)
    plt.show()

    return result

print("\nTesting raw closing prices:")
raw_test = test_stationarity(eth_data['close'])

print("\nTesting differenced prices:")
diff_test = test_stationarity(eth_data['close'].diff().dropna())

def find_best_arima_order(series, max_p=3, max_d=2, max_q=3):
    """Find optimal (p,d,q) using grid search with AIC"""
    best_aic = float('inf')
    best_order = None
    results_list = []

    for p, d, q in itertools.product(range(max_p+1), range(max_d+1), range(max_q+1)):
        try:
            model = ARIMA(series, order=(p, d, q))
            results = model.fit()
            aic = results.aic

            results_list.append({'order': (p, d, q), 'aic': aic})

            if aic < best_aic:
                best_aic = aic
                best_order = (p, d, q)
        except:
            continue

    results_df = pd.DataFrame(results_list).sort_values('aic')
    return best_order, results_df

# Split data into train/test (80-20)
train_size = int(len(eth_data) * 0.8)
train, test = eth_data['close'].iloc[:train_size], eth_data['close'].iloc[train_size:]

# Find best ARIMA order
best_order, candidate_models = find_best_arima_order(train)
print(f"\nBest ARIMA Order: {best_order}")
print("\nTop 5 Model Candidates:")
print(candidate_models.head())

# Train best model
best_model = ARIMA(train, order=best_order).fit()
print(best_model.summary())

def evaluate_model(model, train, test):
    """Evaluate ARIMA model performance"""
    print("\n=== Model Evaluation ===")

    # Generate predictions
    predictions = model.forecast(steps=len(test))

    # Calculate metrics
    rmse = sqrt(mean_squared_error(test, predictions))
    mape = mean_absolute_percentage_error(test, predictions) * 100

    print(f"RMSE: {rmse:.2f}")
    print(f"MAPE: {mape:.2f}%")

    # Plot predictions vs actual
    plt.figure(figsize=(14, 7))
    plt.plot(train.index, train, label='Training Data')
    plt.plot(test.index, test, label='Actual', color='blue')
    plt.plot(test.index, predictions, label='Predicted', color='red')
    plt.title('Actual vs Predicted Prices')
    plt.legend()
    plt.grid(True)
    plt.show()

    return rmse, mape

rmse, mape = evaluate_model(best_model, train, test)

def make_forecast(model, series, days=30):
    """Generate future price forecasts"""
    print(f"\n=== {days}-Day Forecast ===")

    # Refit model on full data
    final_model = ARIMA(series, order=model.model.order)
    final_fit = final_model.fit()

    # Generate forecast
    forecast = final_fit.get_forecast(steps=days)
    forecast_df = pd.DataFrame({
        'forecast': forecast.predicted_mean,
        'lower_ci': forecast.conf_int().iloc[:, 0],
        'upper_ci': forecast.conf_int().iloc[:, 1]
    }, index=pd.date_range(series.index[-1] + timedelta(days=1), periods=days))

    # Plot forecast
    plt.figure(figsize=(14, 7))
    plt.plot(series.index, series, label='Historical')
    plt.plot(forecast_df.index, forecast_df['forecast'], label='Forecast', color='red')
    plt.fill_between(forecast_df.index, forecast_df['lower_ci'], forecast_df['upper_ci'], color='pink', alpha=0.3)
    plt.title(f'{days}-Day ETH Price Forecast')
    plt.legend()
    plt.grid(True)
    plt.show()

    print("\nForecast Results:")
    print(forecast_df)

    return forecast_df

forecast_results = make_forecast(best_model, eth_data['close'])